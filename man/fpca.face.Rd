% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fpca.face.R
\name{fpca.face}
\alias{fpca.face}
\title{Functional principal component analysis with fast covariance estimation}
\usage{
fpca.face(Y = NULL, ydata = NULL, Y.pred = NULL, argvals = NULL,
  pve = 0.99, npc = NULL, var = FALSE, simul = FALSE,
  sim.alpha = 0.95, center = TRUE, knots = 35, p = 3, m = 2,
  lambda = NULL, alpha = 1, search.grid = TRUE, search.length = 100,
  method = "L-BFGS-B", lower = -20, upper = 20, control = NULL,
  integration = "trapezoidal", newdata = NULL, argvals.new = NULL,
  spar.knots = 10, spar.knots.option = "quantile", lambda_mean = NULL,
  spar.search.length = 14, spar.lower = -3, spar.upper = 10,
  spar.lower2 = -1, spar.upper2 = 5, calculate.scores = FALSE)
}
\arguments{
\item{Y, ydata}{the user must supply either \code{Y}, a matrix of functions
observed on a regular grid, or a data frame \code{ydata} representing
irregularly observed functions. See Details.}

\item{Y.pred}{if desired, a matrix of functions to be approximated using
the FPC decomposition.}

\item{argvals}{numeric; function argument.}

\item{pve}{proportion of variance explained: used to choose the number of
principal components.}

\item{npc}{how many smooth SVs to try to extract, if \code{NA} (the
default) the hard thresholding rule of Gavish and Donoho (2014) is used (see
Details, References).}

\item{var}{logical; should an estimate of standard error be returned?}

\item{simul}{logical; if \code{TRUE} curves will we simulated using
Monte Carlo to obtain an estimate of the \code{sim.alpha} quantile at each
\code{argval}; ignored if \code{var == FALSE}.}

\item{sim.alpha}{numeric; if \code{simul==TRUE}, quantile to estimate at
each \code{argval}; ignored if \code{var == FALSE}.}

\item{center}{logical; center \code{Y} so that its column-means are 0? Defaults to
\code{TRUE}.}

\item{knots}{number of knots to use or the vectors of knots; defaults to 35.}

\item{p}{integer; the degree of B-splines functions to use.}

\item{m}{integer; the order of difference penalty to use.}

\item{lambda}{smoothing parameter; if not specified smoothing parameter is
chosen using \code{\link[stats]{optim}} or a grid search.}

\item{alpha}{numeric; tuning parameter for GCV; see parameter \code{gamma}
in \code{\link[mgcv]{gam}}.}

\item{search.grid}{logical; should a grid search be used to find \code{lambda}?
Otherwise, \code{\link[stats]{optim}} is used.}

\item{search.length}{integer; length of grid to use for grid search for
\code{lambda}; ignored if \code{search.grid} is \code{FALSE}.}

\item{method}{method to use; see \code{\link[stats]{optim}}.}

\item{lower}{see \code{\link[stats]{optim}}.}

\item{upper}{see \code{\link[stats]{optim}}.}

\item{control}{see \code{\link[stats]{optim}}.}

\item{integration}{quadrature method for numerical integration; only
\code{'trapezoidal'} is currently supported.}

\item{newdata}{of the same strucutre as \code{ydata}; 
defaults to NULL, then no prediction.}

\item{argvals.new}{a vector of observation time points to evaluate mean 
function, covariance function, error variance and etc. If NULL, then 100 
equidistant points in the range of \code{ydata$argvals}.}

\item{spar.knots}{a vector of interior knots or the number of knots for 
B-spline basis functions to be used for sparse data; defaults to 10.}

\item{spar.knots.option}{if \code{spar.knots} specifies the number of knots, 
then \code{spar.knots.option} will be used for sparse data. Default "quantile": quantiles of 
the observed time points will be selected. Alternatively "equally-spaced", then 
equally-spaced knots in the range of observed time points will be selected.}

\item{lambda_mean}{the value of the smoothing parameter for mean smoothing; defaults to NULL.}

\item{spar.search.length}{the number of equidistant (log scale) smoothing 
parameters to search for sparse data; defaults to 14.}

\item{spar.lower}{lower bounds for log smoothing parameter for first step of 
estimation for sparse data; defaults are -3.}

\item{spar.upper}{upper bounds for log smoothing parameter for first step of 
estimation for sparse data; defaults are 10.}

\item{spar.lower2}{lower bounds for log smoothing parameter for second step of 
estimation for sparse data; defaults are -1.}

\item{spar.upper2}{upper bounds for log smoothing parameter for second step of 
estimation for sparse data; defaults are 5 .}

\item{calculate.scores}{if TRUE, scores will be calculated for sparse data.}
}
\value{
A list with components
\enumerate{
\item \code{Yhat} - If \code{Y.pred} is specified, the smooth version of
\code{Y.pred}.   Otherwise, if \code{Y.pred=NULL}, the smooth version of \code{Y}.
\item \code{Y} - the observed data.
\item \code{scores} - matrix of scores.
\item \code{mu} - mean function.
\item \code{npc} - number of principal components.
\item \code{efunctions} - matrix of eigenvectors.
\item \code{evalues} - vector of eigenvalues.
\item \code{argvals} - the argument values of the function evaluations in Y.
}
if \code{var == TRUE} additional components are returned
\enumerate{
\item \code{sigma2} - estimate of the error variance.
\item \code{VarMats} - list of covariance function estimate for each
subject.
\item \code{diag.var} - diagonal elements of the covariance matrices 
for each estimated curve.
\item \code{crit.val} - list of estimated quantiles; only returned if
\code{simul == TRUE}.
}
}
\description{
A fast implementation of the sandwich smoother (Xiao et al., 2013)
for covariance matrix smoothing. Two options are provided, when input is a data
matrix of dense or regular design, the bivariate smoother is specifically
designed for the covariance matrix of high dimension, pooled generalized 
cross validation at the data level is used for selecting the smoothing parameter; 
when input is a triplet list of sparse or irregular design, the bivariate smoother 
can be used for sparse functional or longitudinal data.
}
\examples{
#### settings
I <- 50 # number of subjects
J <- 3000 # dimension of the data
t <- (1:J)/J # a regular grid on [0,1]
N <- 4 #number of eigenfunctions
sigma <- 2 ##standard deviation of random noises
lambdaTrue <- c(1,0.5,0.5^2,0.5^3) # True eigenvalues
  
case = 1
### True Eigenfunctions
  
if(case==1) phi <- sqrt(2)*cbind(sin(2*pi*t),cos(2*pi*t),
                                sin(4*pi*t),cos(4*pi*t))
if(case==2) phi <- cbind(rep(1,J),sqrt(3)*(2*t-1),
                          sqrt(5)*(6*t^2-6*t+1),
                         sqrt(7)*(20*t^3-30*t^2+12*t-1))

###################################################
########     Generate Data            #############
###################################################
xi <- matrix(rnorm(I*N),I,N);
xi <- xi\\\%*\\\%diag(sqrt(lambdaTrue))
X <- xi\\\%*\\\%t(phi); # of size I by J
Y <- X + sigma*matrix(rnorm(I*J),I,J)

results <- fpca.face(Y,center = TRUE, argvals=t,knots=100,pve=0.99)
###################################################
####               FACE                ########
###################################################  
Phi <- results$efunctions
eigenvalues <- results$evalues

for(k in 1:N){
  if(Phi[,k]\\\%*\\\%phi[,k]< 0) 
    Phi[,k] <- - Phi[,k]
}

### plot eigenfunctions
par(mfrow=c(N/2,2))
seq <- (1:(J/10))*10
for(k in 1:N){
  plot(t[seq],Phi[seq,k]*sqrt(J),type="l",lwd = 3, 
       ylim = c(-2,2),col = "red",
       ylab = paste("Eigenfunction ",k,sep=""),
       xlab="t",main="FACE")
  
  lines(t[seq],phi[seq,k],lwd = 2, col = "black")
}

##################################################
########     CD4 Data Example (Sparse Data) ######
##################################################
data(cd4)
n <- nrow(cd4)
T <- ncol(cd4)
id <- rep(1:n,each=T)
t <- rep(-18:42,times=n)
y <- as.vector(t(cd4))
sel <- which(is.na(y))
## organize data and apply fpca.face
data <- data.frame(y=log(y[-sel]),argvals = t[-sel],subj = id[-sel])
data <- data[data$y>4.5,]
tnew <- seq(-18,42)
tnew <- tnew[!tnew==0]
fit_face <- fpca.face(ydata=data,argvals.new=tnew,var=TRUE)


}
\author{
Luo Xiao \email{lxiao5@ncsu.edu}, Cai Li \email{cli9@ncsu.edu}
}
\references{
Xiao, L., Li, Y., and Ruppert, D. (2013).
Fast bivariate \emph{P}-splines: the sandwich smoother,
\emph{Journal of the Royal Statistical Society: Series B}, 75(3), 577-599.

Xiao, L., Ruppert, D., Zipunnikov, V., and Crainiceanu, C. (2016).
Fast covariance estimation for high-dimensional functional data.  
\emph{Statistics and Computing}, 26, 409-421.
DOI: 10.1007/s11222-014-9485-x.

Xiao, L., Li, C., Checkley, W., and Crainiceanu, C. (2016). 
Fast covariance estimation for sparse functional data, manuscript.
}
\seealso{
\code{\link{fpca.sc}}  for another covariance-estimate based
smoothing of \code{Y}; \code{\link{fpca2s}} and \code{\link{fpca.ssvd}}
for two SVD-based smoothings.
}

